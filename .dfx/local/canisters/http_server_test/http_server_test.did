type _anon_class_8_1 = 
 service {
   authorize: (principal) -> ();
   clear: (ClearArguments) -> ();
   commit_batch: (CommitBatchArguments) -> ();
   create_asset: (CreateAssetArguments) -> ();
   create_batch: (record {}) -> (record {batch_id: BatchId;});
   create_chunk: (record {
                    batch_id: BatchId;
                    content: blob;
                  }) -> (record {chunk_id: ChunkId;});
   delete_asset: (DeleteAssetArguments) -> ();
   get: (record {
           accept_encodings: vec text;
           key: Key;
         }) ->
    (record {
       content: blob;
       content_encoding: text;
       content_type: text;
       sha256: opt blob;
       total_length: nat;
     }) query;
   http_request: (HttpRequest) -> (HttpResponse) query;
   http_request_streaming_callback: (StreamingCallbackToken) ->
    (StreamingCallbackHttpResponse__1) query;
   http_request_update: (HttpRequest) -> (HttpResponse);
   invalidate_cache: () -> ();
   list: (record {}) -> (vec AssetDetails) query;
   retrieve: (Path) -> (Contents) query;
   set_asset_content: (SetAssetContentArguments) -> ();
   store:
    (record {
       content: blob;
       content_encoding: text;
       content_type: text;
       key: Key__1;
       sha256: opt blob;
     }) -> ();
   unset_asset_content: (UnsetAssetContentArguments) -> ();
   whoAmI: () -> (principal) query;
 };
type UnsetAssetContentArguments = 
 record {
   content_encoding: text;
   key: Key;
 };
type Token = record {arbitrary_data: text;};
type Time = int;
type StreamingStrategy = variant {Callback: CallbackStrategy;};
type StreamingCallbackToken__1 = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
   sha256: opt blob;
 };
type StreamingCallbackToken = 
 record {
   content_encoding: text;
   index: nat;
   key: text;
   sha256: opt blob;
 };
type StreamingCallbackHttpResponse__1 = 
 record {
   body: blob;
   token: opt StreamingCallbackToken__1;
 };
type StreamingCallbackHttpResponse = 
 record {
   body: blob;
   token: opt Token;
 };
type SetAssetContentArguments = 
 record {
   chunk_ids: vec ChunkId;
   content_encoding: text;
   key: Key;
   sha256: opt blob;
 };
type Path = text;
type Key__1 = text;
type Key = text;
type HttpResponse = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy: opt StreamingStrategy;
   upgrade: opt bool;
 };
type HttpRequest = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type HeaderField = 
 record {
   text;
   text;
 };
type DeleteAssetArguments = record {key: Key;};
type CreateAssetArguments = 
 record {
   content_type: text;
   key: Key;
 };
type Contents = blob;
type CommitBatchArguments = 
 record {
   batch_id: BatchId;
   operations: vec BatchOperationKind;
 };
type ClearArguments = record {};
type ChunkId = nat;
type CallbackStrategy = 
 record {
   callback: func (Token) -> (StreamingCallbackHttpResponse) query;
   token: Token;
 };
type BatchOperationKind = 
 variant {
   Clear: ClearArguments;
   CreateAsset: CreateAssetArguments;
   DeleteAsset: DeleteAssetArguments;
   SetAssetContent: SetAssetContentArguments;
   UnsetAssetContent: UnsetAssetContentArguments;
 };
type BatchId = nat;
type AssetEncodingDetails = 
 record {
   content_encoding: text;
   length: nat;
   modified: Time;
   sha256: opt blob;
 };
type AssetDetails = 
 record {
   content_type: text;
   encodings: vec AssetEncodingDetails;
   key: Key;
 };
service : () -> _anon_class_8_1
