This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-30T17:46:39.336Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  assets/
    index.html
    index.js
  main.mo
dfx.json
Makefile
mops.toml
package.json
upload.js

================================================================
Repository Files
================================================================

================
File: src/assets/index.html
================
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>My First IC Web Page</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      color: #2f80ed;
    }
    .energy-bar-container {
      width: 100%;
      background-color: #f0f0f0;
      padding: 10px;
      border-radius: 8px;
      margin: 20px 0;
    }
    .energy-bar {
      width: 100%;
      height: 30px;
      background: #ddd;
      border-radius: 5px;
      overflow: hidden;
      position: relative;
    }
    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
      transition: width 0.5s ease-in-out;
      border-radius: 5px;
    }
    .energy-text {
      position: absolute;
      width: 100%;
      text-align: center;
      line-height: 30px;
      color: #000;
      font-weight: bold;
      text-shadow: 1px 1px 1px rgba(255,255,255,0.5);
    }
    .energy-details {
      display: flex;
      justify-content: space-between;
      margin-top: 5px;
      font-size: 0.9em;
      color: #666;
    }
  </style>
</head>
<body>
  <h1>Hello from the Internet Computer!</h1>
  <p>This is a static page served from my canister.</p>
  
  <div class="energy-bar-container">
    <h3>Energy level</h3>
    <div class="energy-bar">
      <div class="energy-fill" id="energy-fill"></div>
      <div class="energy-text" id="energy-text"></div>
    </div>
    <div class="energy-details">
      <span id="raw-balance"></span>
      <span id="percentage"></span>
    </div>
  </div>

  <!-- <img src="unnamed.webp" alt="" width="200px"> -->
  <script src="index.js" type="module"></script>
</body>
</html>

================
File: src/assets/index.js
================
function formatCycles(cycles) {
    if (cycles >= 1_000_000_000_000) {
        return (cycles / 1_000_000_000_000).toFixed(2) + ' T';
    } else if (cycles >= 1_000_000_000) {
        return (cycles / 1_000_000_000).toFixed(2) + ' B';
    } else if (cycles >= 1_000_000) {
        return (cycles / 1_000_000).toFixed(2) + ' M';
    } else if (cycles >= 1_000) {
        return (cycles / 1_000).toFixed(2) + ' K';
    }
    return cycles.toString();
}

const MAX_CYCLES = 10_000_000_000_000;

async function updateBalance() {
    try {
        const response = await fetch('/balance', {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
            },
        });
        
        const balance = parseInt(await response.text());
        
        // Calculate percentage (capped at 100%)
        const percentage = Math.min((balance / MAX_CYCLES) * 100, 100);
        
        // Update energy bar
        const energyFill = document.getElementById('energy-fill');
        energyFill.style.width = `${percentage}%`;
        
        // Update text displays
        document.getElementById('energy-text').innerText = 
            `${formatCycles(balance)} cycles`;
        document.getElementById('raw-balance').innerText = 
            `Total: ${formatCycles(balance)} cycles`;
        document.getElementById('percentage').innerText = 
            `${percentage.toFixed(1)}% of max capacity`;

        // Change color based on percentage
        if (percentage < 20) {
            energyFill.style.background = 'linear-gradient(90deg, #ff5252, #ff8a80)';
        } else if (percentage < 50) {
            energyFill.style.background = 'linear-gradient(90deg, #ffd740, #ffecb3)';
        } else {
            energyFill.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
        }

    } catch (error) {
        console.error('Error fetching balance:', error);
    }
}

// Update balance initially and every 5 seconds
updateBalance();
setInterval(updateBalance, 5000);

================
File: src/main.mo
================
import Server "mo:server";
import Debug "mo:base/Debug";
import Iter "mo:base/Iter";
import serdeJson "mo:serde/JSON";
import Text "mo:base/Text";
import Nat "mo:base/Nat";
import Buffer "mo:base/Buffer";
import Array "mo:base/Array";
import Assets "mo:assets";
import T "mo:assets/Types";
import Cycles "mo:base/ExperimentalCycles"

shared ({ caller = creator }) actor class () {
  type Request = Server.Request;
  type Response = Server.Response;
  type HttpRequest = Server.HttpRequest;
  type HttpResponse = Server.HttpResponse;
  type ResponseClass = Server.ResponseClass;

  stable var serializedEntries : Server.SerializedEntries = ([], [], [creator]);

  var server = Server.Server({ serializedEntries });

  public query ({ caller }) func whoAmI() : async Principal {
		return caller;
	};

    server.get(
  "/balance",
  func(_ : Request, res : ResponseClass) : async Response {
    let balance = Nat.toText(Cycles.balance());
    res.send({
      status_code = 200;
      headers = [("Content-Type", "text/plain")];
      body = Text.encodeUtf8(balance);
      streaming_strategy = null;
      cache_strategy = #noCache;
    });
  },
);

  server.get(
    "/",
    func(_ : Request, res : ResponseClass) : async Response {
      res.send({
        status_code = 200;
        headers = [("Content-Type", "text/html")];
        body = Text.encodeUtf8(
          "<html><body><h1>hello world</h1></body></html>"
        );
        streaming_strategy = null;
        cache_strategy = #noCache;
      });
    },
  );

  // Cached endpoint
  server.get(
    "/hi",
    func(_ : Request, res : ResponseClass) : async Response {
        Debug.print("Hit /hi endpoint");  
      res.send({
        headers = [("Content-Type", "text/plain")];
        status_code = 200;
        body = Text.encodeUtf8("hi");
        streaming_strategy = null;
        cache_strategy = #noCache;
      });
    },
  );

  server.get(
    "/json",
    func(_ : Request, res : ResponseClass) : async Response {
      res.json({
        status_code = 200;
        body = "{\"hello\":\"world\"}";
        cache_strategy = #noCache;
      });
    },
  );

  server.get(
    "/404",
    func(_ : Request, res : ResponseClass) : async Response {
      res.send({
        status_code = 404;
        headers = [("Content-Type", "text/plain")];
        body = Text.encodeUtf8("Not found");
        streaming_strategy = null;
        cache_strategy = #noCache;
      });
    },
  );

  // server.get("/redirect",
  //   func(req, res) : Response {
  //     res.redirect("/hi");
  //   },
  // );

  // Dynamic endpoint
  server.get(
    "/queryParams",
    func(req : Request, res : ResponseClass) : async Response {
      let obj = req.url.queryObj;
      let keys = Iter.fromArray(obj.keys);

      var body = "{";

      for (key in keys) {
        let value = obj.get(key);
        switch value {
          case null {};
          case (?value) {
            body := body # "\"" # key # "\":\"" # value # "\",";
          };
        };
      };
      // trim the last comma
      body := Text.trimEnd(body, #text ",");

      body := body # "}";

      res.json({
        status_code = 200;
        body = body;
        cache_strategy = #noCache;
      });
    },
  );

  type Cat = {
    name : Text;
    age : Nat;
  };
  var cats = [
    {
      name = "Sardine";
      age = 7;
    },
    {
      name = "Olive";
      age = 4;
    },
  ];

  func displayCat(cat : Cat) : Text {
    "{\"name\":\"" # cat.name # "\",\"age\":" # Nat.toText(cat.age) # "}";
  };

  server.get(
    "/cats",
    func(_ : Request, res : ResponseClass) : async Response {
      var catJson = "[";
      for (cat in Iter.fromArray(cats)) {
        catJson := catJson # displayCat(cat) # ",";
      };
      catJson := Text.trimEnd(catJson, #text ",");
      catJson := catJson # "]";

      res.json({
        status_code = 200;
        body = catJson;
        cache_strategy = #noCache;
      });
    },
  );

  server.get(
    "/cats/:name",
    func(req : Request, res : ResponseClass) : async Response {
      switch (req.params) {
        case null {
          res.send({
            status_code = 400;
            headers = [];
            body = Text.encodeUtf8("Invalid path");
            streaming_strategy = null;
            cache_strategy = #noCache;
          });
        };
        case (?params) {
          let name = params.get("name");
          switch name {
            case null {
              res.send({
                status_code = 400;
                headers = [];
                body = Text.encodeUtf8("Invalid path");
                streaming_strategy = null;
                cache_strategy = #noCache;
              });
            };
            case (?n) {
              let cat = Array.find(
                cats,
                func(cat : Cat) : Bool {
                  Text.toLowercase(cat.name) == Text.toLowercase(n);
                },
              );
              switch cat {
                case null {
                  res.send({
                    status_code = 404;
                    headers = [];
                    body = Text.encodeUtf8("Cat not found");
                    streaming_strategy = null;
                    cache_strategy = #noCache;
                  });
                };
                case (?cat) {
                  res.json({
                    status_code = 200;
                    body = displayCat(cat);
                    cache_strategy = #noCache;
                  });
                };
              };
            };
          };
        };
      };
    },
  );

  /*
  * from shape:
  {
    #Array : [JSON__207];
    #Boolean : Bool;
    #Null;
    #Number : Int;
    #Object : [(Text, JSON__207)];
    #String : Text
  };
  */
  func processCat(data : Text) : ?Cat {
    let #ok(blob) = serdeJson.fromText(data, null) else return null;
    let cat : ?Cat = from_candid (blob);
  };

  public func getCats() : async [Cat] {
    cats;
  };

  server.post(
    "/cats",
    func(req : Request, res : ResponseClass) : async Response {
      let body = req.body;
      switch body {
        case null {
          res.send({
            status_code = 400;
            headers = [];
            body = Text.encodeUtf8("Invalid JSON");
            streaming_strategy = null;
            cache_strategy = #noCache;
          });
        };
        case (?body) {

          let bodyText = body.text();
          let cat = processCat(bodyText);
          switch (cat) {
            case (null) {
              res.send({
                status_code = 400;
                headers = [];
                body = Text.encodeUtf8("Invalid JSON");
                streaming_strategy = null;
                cache_strategy = #noCache;
              });
            };
            case (?cat) {
              let buf : Buffer.Buffer<Cat> = Buffer.fromArray(cats);
              buf.add(cat);
              cats := Buffer.toArray(buf);
              res.json({
                status_code = 200;
                body = "ok";
                cache_strategy = #noCache;
              });
            };
          };
        };
      };
    },
  );

   let assets = server.assets;

  public shared ({ caller }) func authorize(other : Principal) : async () {
    server.authorize({ caller; other });
  };

  public query func retrieve(path : Assets.Path) : async Assets.Contents {
    assets.retrieve(path);
  };

  public shared ({ caller }) func store(
    arg : {
      key : Assets.Key;
      content_type : Text;
      content_encoding : Text;
      content : Blob;
      sha256 : ?Blob;
    }
  ) : async () {
    server.store({ caller; arg });
  };


  // Bind the server to the HTTP interface
  public query func http_request(req : HttpRequest) : async HttpResponse {
    server.http_request(req);
  };
  public func http_request_update(req : HttpRequest) : async HttpResponse {
    await server.http_request_update(req);
  };

  public func invalidate_cache() : async () {
    server.empty_cache();
  };

  system func preupgrade() {
    serializedEntries := server.entries();
  };

  system func postupgrade() {
    ignore server.cache.pruneAll();
  };

  // Add these methods in your main.mo
public query func list(arg : {}) : async [T.AssetDetails] {
  assets.list(arg);
};

public query func get(
  arg : {
    key : T.Key;
    accept_encodings : [Text];
  }
) : async ({
  content : Blob;
  content_type : Text;
  content_encoding : Text;
  total_length : Nat;
  sha256 : ?Blob;
}) {
  assets.get(arg);
};

public shared ({ caller }) func create_batch(arg : {}) : async ({
  batch_id : T.BatchId;
}) {
  assets.create_batch({
    caller;
    arg;
  });
};

public shared ({ caller }) func create_chunk(
  arg : {
    batch_id : T.BatchId;
    content : Blob;
  }
) : async ({
  chunk_id : T.ChunkId;
}) {
  assets.create_chunk({
    caller;
    arg;
  });
};

public shared ({ caller }) func commit_batch(args : T.CommitBatchArguments) : async () {
  assets.commit_batch({
    caller;
    args;
  });
};

public shared ({ caller }) func create_asset(arg : T.CreateAssetArguments) : async () {
  assets.create_asset({
    caller;
    arg;
  });
};

public shared ({ caller }) func set_asset_content(arg : T.SetAssetContentArguments) : async () {
  assets.set_asset_content({
    caller;
    arg;
  });
};

public shared ({ caller }) func unset_asset_content(args : T.UnsetAssetContentArguments) : async () {
  assets.unset_asset_content({
    caller;
    args;
  });
};

public shared ({ caller }) func delete_asset(args : T.DeleteAssetArguments) : async () {
  assets.delete_asset({
    caller;
    args;
  });
};

public shared ({ caller }) func clear(args : T.ClearArguments) : async () {
  assets.clear({
    caller;
    args;
  });
};

public type StreamingCallbackToken = {
  key : Text;
  content_encoding : Text;
  index : Nat;
  sha256 : ?Blob;
};

public type StreamingCallbackHttpResponse = {
  body : Blob;
  token : ?StreamingCallbackToken;
};

public query func http_request_streaming_callback(token : T.StreamingCallbackToken) : async StreamingCallbackHttpResponse {
  assets.http_request_streaming_callback(token);
};

};

================
File: dfx.json
================
{
    "canisters": {
      "http_server_test": {
        "main": "src/main.mo",
        "type": "motoko"
      }
    },
    "defaults": {
      "build": {
        "args": "",
        "packtool": "mops sources"
      }
    },
    "version": 1
  }

================
File: Makefile
================
# Access routes in a local replica
# canisterId.localhost:4943/whatever_route
# http://bw4dl-smaaa-aaaaa-qaacq-cai.localhost:4943/hi

================
File: mops.toml
================
[package]
name = "http_demo"
version = "0.1.0"
description = "A simple HTTP server demo"

[dependencies]
base = "0.12.1"
server = "1.0.0"
http-parser = "0.3.1"
assets = "0.2.2"

================
File: package.json
================
{
    "name": "http_demo",
    "version": "0.1.0",
    "description": "A simple HTTP server demo",
    "scripts": {
      "upload": "node upload.js"
    },
    "dependencies": {
      "@dfinity/agent": "^2.1.3",
      "@dfinity/assets": "^2.1.3",
      "@dfinity/identity": "^2.1.3"
    }
  }

================
File: upload.js
================
const { HttpAgent } = require("@dfinity/agent");
const fs = require("fs");
const path = require("path");
const { Ed25519KeyIdentity } = require("@dfinity/identity");
const { AssetManager } = require("@dfinity/assets");
const { spawn } = require("child_process");

// Create a test identity
const encoder = new TextEncoder();
const seed = new Uint8Array(32);
const base = encoder.encode("test");
seed.set(base, 0);
seed.fill(0);
const testIdentity = Ed25519KeyIdentity.generate(seed);

const canisterId = "bw4dl-smaaa-aaaaa-qaacq-cai"; // Your canister ID
const HOST = `http://127.0.0.1:4943`;

// First authorize the identity
console.log("Authorizing identity...");
const child = spawn("dfx", [
  "canister",
  "call",
  "http_server_test",
  "authorize",
  `(principal "${testIdentity.getPrincipal().toText()}")`,
]);

child.stdout.on("data", (data) => {
  console.log(`Authorization success: ${data}`);
});

child.stderr.on("data", (data) => {
  console.error(`Authorization error: ${data}`);
});

// Only proceed with upload after authorization
child.on("close", (code) => {
  if (code === 0) {
    uploadAssets();
  }
});

async function uploadAssets() {
  const agent = new HttpAgent({ 
    host: HOST,
    identity: testIdentity 
  });
  await agent.fetchRootKey();

  const assetManager = new AssetManager({
    canisterId,
    agent,
  });

  const assets = [];
  fs.readdirSync(path.join(__dirname, "src/assets")).forEach((file) => {
    assets.push([file, fs.readFileSync(path.join(__dirname, "src/assets", file))]);
  });

  console.log(`Uploading ${assets.length} files...`);
  
  for (const [name, file] of assets) {
    const key = await assetManager.store(file, { fileName: name });
    const asset = await assetManager.get(key);
    console.log(`Uploaded ${name}, size: ${asset.length} bytes`);
  }
}
